//go:build generate

// Package main contains code generators for the go-qbittorrent project.
// This generator creates torrent sorting and filtering functions.
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
)

type FilterFieldInfo struct {
	Name    string
	JSONTag string
	Type    string
	GoType  string
}

func main() {
	// Parse the domain.go file to extract Torrent struct
	fset := token.NewFileSet()
	domainFile := "domain.go"
	file, err := parser.ParseFile(fset, domainFile, nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	var torrentFields []FilterFieldInfo

	// Find the Torrent struct
	ast.Inspect(file, func(n ast.Node) bool {
		if ts, ok := n.(*ast.TypeSpec); ok {
			if ts.Name.Name == "Torrent" {
				if st, ok := ts.Type.(*ast.StructType); ok {
					torrentFields = parseFilterFields(st)
				}
			}
		}
		return true
	})

	if len(torrentFields) == 0 {
		log.Fatal("No Torrent struct found")
	}

	// Generate the filter file
	generateFilterFile(torrentFields)
}

func parseFilterFields(st *ast.StructType) []FilterFieldInfo {
	var fields []FilterFieldInfo

	for _, field := range st.Fields.List {
		if len(field.Names) == 0 {
			continue // Skip embedded fields
		}

		fieldName := field.Names[0].Name
		if !isExported(fieldName) {
			continue // Skip unexported fields
		}

		var jsonTag string
		if field.Tag != nil {
			tag := field.Tag.Value
			// Extract JSON tag
			if strings.Contains(tag, "json:") {
				start := strings.Index(tag, `json:"`) + 6
				if start > 5 {
					end := strings.Index(tag[start:], `"`)
					if end > 0 {
						jsonTag = tag[start : start+end]
						// Remove omitempty and other options
						if commaIdx := strings.Index(jsonTag, ","); commaIdx > 0 {
							jsonTag = jsonTag[:commaIdx]
						}
					}
				}
			}
		}

		// Skip fields without JSON tags or with "-" tag
		if jsonTag == "" || jsonTag == "-" {
			continue
		}

		goType := getTypeString(field.Type)
		fields = append(fields, FilterFieldInfo{
			Name:    fieldName,
			JSONTag: jsonTag,
			Type:    goType,
			GoType:  goType,
		})
	}

	return fields
}

func getTypeString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + getTypeString(t.X)
	case *ast.ArrayType:
		return "[]" + getTypeString(t.Elt)
	case *ast.SelectorExpr:
		return getTypeString(t.X) + "." + t.Sel.Name
	default:
		return "interface{}"
	}
}

func isExported(name string) bool {
	return len(name) > 0 && name[0] >= 'A' && name[0] <= 'Z'
}

func generateFilterFile(fields []FilterFieldInfo) {
	output := `// Code generated by go generate; DO NOT EDIT.
// This file was generated by internal/codegen/generate_torrent_filter.go

package qbittorrent

import (
	"cmp"
	"slices"
)

// applyTorrentSorting applies sorting to torrents based on the sort field
func applyTorrentSorting(torrents []Torrent, sortField string, reverse bool) {
	if sortField == "" {
		return
	}

	slices.SortFunc(torrents, func(a, b Torrent) int {
		result := cmp.Or(
			func() int {
				switch sortField {
`

	// Generate switch cases for each field
	for _, field := range fields {
		if field.Type == "bool" {
			output += fmt.Sprintf(`				case "%s":
					if a.%s != b.%s {
						if a.%s {
							return 1
						}
						return -1
					}
					return 0
`, field.JSONTag, field.Name, field.Name, field.Name)
		} else if isComparableType(field.Type) {
			output += fmt.Sprintf(`				case "%s":
					return cmp.Compare(a.%s, b.%s)
`, field.JSONTag, field.Name, field.Name)
		} else if field.Type == "TorrentState" {
			output += fmt.Sprintf(`				case "%s":
					return cmp.Compare(string(a.%s), string(b.%s))
`, field.JSONTag, field.Name, field.Name)
		}
	}

	output += `				default:
					return cmp.Compare(a.Name, b.Name) // default to name
				}
			}(),
			cmp.Compare(a.Hash, b.Hash), // secondary sort by hash for stability
		)

		if reverse {
			return -result
		}
		return result
	})
}
`

	// Write to file
	err := os.WriteFile("filter_generated.go", []byte(output), 0644)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Generated filter_generated.go with %d sortable fields\n", len(fields))
}

func isComparableType(goType string) bool {
	comparableTypes := map[string]bool{
		"string":  true,
		"int":     true,
		"int8":    true,
		"int16":   true,
		"int32":   true,
		"int64":   true,
		"uint":    true,
		"uint8":   true,
		"uint16":  true,
		"uint32":  true,
		"uint64":  true,
		"float32": true,
		"float64": true,
		// Note: bool is NOT part of cmp.Ordered and needs special handling
	}
	return comparableTypes[goType]
}

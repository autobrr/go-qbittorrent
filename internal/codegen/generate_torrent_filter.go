//go:build generate

// Package main contains code generators for the go-qbittorrent project.
// This generator creates torrent sorting and filtering functions.
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
)

type FilterFieldInfo struct {
	Name    string
	JSONTag string
	Type    string
	GoType  string
}

func main() {
	// Parse the domain.go file to extract Torrent struct
	fset := token.NewFileSet()
	domainFile := "domain.go"
	file, err := parser.ParseFile(fset, domainFile, nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	var torrentFields []FilterFieldInfo

	// Find the Torrent struct
	ast.Inspect(file, func(n ast.Node) bool {
		if ts, ok := n.(*ast.TypeSpec); ok {
			if ts.Name.Name == "Torrent" {
				if st, ok := ts.Type.(*ast.StructType); ok {
					torrentFields = parseFilterFields(st)
				}
			}
		}
		return true
	})

	if len(torrentFields) == 0 {
		log.Fatal("No Torrent struct found")
	}

	// Generate the filter file
	generateFilterFile(torrentFields)
}

func parseFilterFields(st *ast.StructType) []FilterFieldInfo {
	var fields []FilterFieldInfo

	for _, field := range st.Fields.List {
		if len(field.Names) == 0 {
			continue // Skip embedded fields
		}

		fieldName := field.Names[0].Name
		if !isExported(fieldName) {
			continue // Skip unexported fields
		}

		var jsonTag string
		if field.Tag != nil {
			tag := field.Tag.Value
			// Extract JSON tag
			if strings.Contains(tag, "json:") {
				start := strings.Index(tag, `json:"`) + 6
				if start > 5 {
					end := strings.Index(tag[start:], `"`)
					if end > 0 {
						jsonTag = tag[start : start+end]
						// Remove omitempty and other options
						if commaIdx := strings.Index(jsonTag, ","); commaIdx > 0 {
							jsonTag = jsonTag[:commaIdx]
						}
					}
				}
			}
		}

		// Skip fields without JSON tags or with "-" tag
		if jsonTag == "" || jsonTag == "-" {
			continue
		}

		goType := getTypeString(field.Type)
		fields = append(fields, FilterFieldInfo{
			Name:    fieldName,
			JSONTag: jsonTag,
			Type:    goType,
			GoType:  goType,
		})
	}

	return fields
}

func getTypeString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + getTypeString(t.X)
	case *ast.ArrayType:
		return "[]" + getTypeString(t.Elt)
	case *ast.SelectorExpr:
		return getTypeString(t.X) + "." + t.Sel.Name
	default:
		return "interface{}"
	}
}

func isExported(name string) bool {
	return len(name) > 0 && name[0] >= 'A' && name[0] <= 'Z'
}

func generateFilterFile(fields []FilterFieldInfo) {
	output := `// Code generated by go generate; DO NOT EDIT.
// This file was generated by internal/codegen/generate_torrent_filter.go

package qbittorrent

import (
	"slices"
	"strings"
)
`

	// Generate comparator functions for each field
	for _, field := range fields {
		if field.Type == "bool" {
			output += fmt.Sprintf(`func compare%s(a, b *Torrent) int {
	if a.%s != b.%s {
		if a.%s {
			return 1
		}
		return -1
	}
	return 0
}

`, field.Name, field.Name, field.Name, field.Name)
		} else if field.Type == "string" {
			output += fmt.Sprintf(`func compare%s(a, b *Torrent) int {
	return strings.Compare(a.%s, b.%s)
}

`, field.Name, field.Name, field.Name)
		} else if isComparableType(field.Type) {
			output += fmt.Sprintf(`func compare%s(a, b *Torrent) int {
	if a.%s < b.%s {
		return -1
	} else if a.%s > b.%s {
		return 1
	}
	return 0
}

`, field.Name, field.Name, field.Name, field.Name, field.Name)
		} else if field.Type == "TorrentState" {
			output += fmt.Sprintf(`func compare%s(a, b *Torrent) int {
	return strings.Compare(string(a.%s), string(b.%s))
}

`, field.Name, field.Name, field.Name)
		}
	}

	// Default comparator function
	output += `func compareDefault(a, b *Torrent) int {
	return strings.Compare(a.Name, b.Name)
}

// Precomputed comparators for sorting torrents
var torrentComparators = map[string]func(a, b *Torrent) int{
`

	// Generate map entries
	for _, field := range fields {
		if field.Type == "bool" || isComparableType(field.Type) || field.Type == "TorrentState" {
			output += fmt.Sprintf(`	"%s": compare%s,
`, field.JSONTag, field.Name)
		}
	}

	output += `	"default": compareDefault,
}

// torrentSorter is a reusable struct for sorting torrents without allocations
type torrentSorter struct {
	torrents   []Torrent
	comparator func(a, b *Torrent) int
	reverse    bool
}

// compare is a static method that doesn't allocate
func (s *torrentSorter) compare(i, j int) int {
	result := s.comparator(&s.torrents[i], &s.torrents[j])
	if result == 0 {
		result = strings.Compare(s.torrents[i].Hash, s.torrents[j].Hash) // secondary sort by hash for stability
	}
	if s.reverse {
		return -result
	}
	return result
}

func applyTorrentSorting(torrents []Torrent, sortField string, reverse bool) {
	comparator, exists := torrentComparators[sortField]
	if !exists {
		comparator = torrentComparators["default"]
	}

	// Create indices to sort instead of large structs
	indices := make([]int, len(torrents))
	for i := range indices {
		indices[i] = i
	}

	// Get a sorter from the pool
	sorter := &torrentSorter{
		torrents:  torrents,
		comparator: comparator,
		reverse:   reverse,
	}

	// Sort indices using the static method - no allocation!
	slices.SortFunc(indices, sorter.compare)

	// Apply permutation in place using cycle decomposition
	for i := 0; i < len(torrents); i++ {
		if indices[i] != i {
			// Start of a cycle
			temp := torrents[i]
			j := i
			for {
				k := indices[j]
				indices[j] = j // Mark as processed
				if k == i {
					torrents[j] = temp
					break
				}
				torrents[j] = torrents[k]
				j = k
			}
		}
	}
}
`

	// Write to file
	err := os.WriteFile("filter_generated.go", []byte(output), 0644)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Generated filter_generated.go with %d sortable fields\n", len(fields))
}

func isComparableType(goType string) bool {
	comparableTypes := map[string]bool{
		"string":  true,
		"int":     true,
		"int8":    true,
		"int16":   true,
		"int32":   true,
		"int64":   true,
		"uint":    true,
		"uint8":   true,
		"uint16":  true,
		"uint32":  true,
		"uint64":  true,
		"float32": true,
		"float64": true,
		// Note: bool is NOT part of cmp.Ordered and needs special handling
	}
	return comparableTypes[goType]
}

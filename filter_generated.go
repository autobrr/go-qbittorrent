// Code generated by go generate; DO NOT EDIT.
// This file was generated by internal/codegen/generate_torrent_filter.go

package qbittorrent

import (
	"slices"
	"strings"
)
func compareAddedOn(a, b *Torrent) int {
	if a.AddedOn < b.AddedOn {
		return -1
	} else if a.AddedOn > b.AddedOn {
		return 1
	}
	return 0
}

func compareAmountLeft(a, b *Torrent) int {
	if a.AmountLeft < b.AmountLeft {
		return -1
	} else if a.AmountLeft > b.AmountLeft {
		return 1
	}
	return 0
}

func compareAutoManaged(a, b *Torrent) int {
	if a.AutoManaged != b.AutoManaged {
		if a.AutoManaged {
			return 1
		}
		return -1
	}
	return 0
}

func compareAvailability(a, b *Torrent) int {
	if a.Availability < b.Availability {
		return -1
	} else if a.Availability > b.Availability {
		return 1
	}
	return 0
}

func compareCategory(a, b *Torrent) int {
	return strings.Compare(a.Category, b.Category)
}

func compareCompleted(a, b *Torrent) int {
	if a.Completed < b.Completed {
		return -1
	} else if a.Completed > b.Completed {
		return 1
	}
	return 0
}

func compareCompletionOn(a, b *Torrent) int {
	if a.CompletionOn < b.CompletionOn {
		return -1
	} else if a.CompletionOn > b.CompletionOn {
		return 1
	}
	return 0
}

func compareContentPath(a, b *Torrent) int {
	return strings.Compare(a.ContentPath, b.ContentPath)
}

func compareDlLimit(a, b *Torrent) int {
	if a.DlLimit < b.DlLimit {
		return -1
	} else if a.DlLimit > b.DlLimit {
		return 1
	}
	return 0
}

func compareDlSpeed(a, b *Torrent) int {
	if a.DlSpeed < b.DlSpeed {
		return -1
	} else if a.DlSpeed > b.DlSpeed {
		return 1
	}
	return 0
}

func compareDownloadPath(a, b *Torrent) int {
	return strings.Compare(a.DownloadPath, b.DownloadPath)
}

func compareDownloaded(a, b *Torrent) int {
	if a.Downloaded < b.Downloaded {
		return -1
	} else if a.Downloaded > b.Downloaded {
		return 1
	}
	return 0
}

func compareDownloadedSession(a, b *Torrent) int {
	if a.DownloadedSession < b.DownloadedSession {
		return -1
	} else if a.DownloadedSession > b.DownloadedSession {
		return 1
	}
	return 0
}

func compareETA(a, b *Torrent) int {
	if a.ETA < b.ETA {
		return -1
	} else if a.ETA > b.ETA {
		return 1
	}
	return 0
}

func compareFirstLastPiecePrio(a, b *Torrent) int {
	if a.FirstLastPiecePrio != b.FirstLastPiecePrio {
		if a.FirstLastPiecePrio {
			return 1
		}
		return -1
	}
	return 0
}

func compareForceStart(a, b *Torrent) int {
	if a.ForceStart != b.ForceStart {
		if a.ForceStart {
			return 1
		}
		return -1
	}
	return 0
}

func compareHash(a, b *Torrent) int {
	return strings.Compare(a.Hash, b.Hash)
}

func compareInfohashV1(a, b *Torrent) int {
	return strings.Compare(a.InfohashV1, b.InfohashV1)
}

func compareInfohashV2(a, b *Torrent) int {
	return strings.Compare(a.InfohashV2, b.InfohashV2)
}

func compareLastActivity(a, b *Torrent) int {
	if a.LastActivity < b.LastActivity {
		return -1
	} else if a.LastActivity > b.LastActivity {
		return 1
	}
	return 0
}

func compareMagnetURI(a, b *Torrent) int {
	return strings.Compare(a.MagnetURI, b.MagnetURI)
}

func compareMaxRatio(a, b *Torrent) int {
	if a.MaxRatio < b.MaxRatio {
		return -1
	} else if a.MaxRatio > b.MaxRatio {
		return 1
	}
	return 0
}

func compareMaxSeedingTime(a, b *Torrent) int {
	if a.MaxSeedingTime < b.MaxSeedingTime {
		return -1
	} else if a.MaxSeedingTime > b.MaxSeedingTime {
		return 1
	}
	return 0
}

func compareName(a, b *Torrent) int {
	return strings.Compare(a.Name, b.Name)
}

func compareNumComplete(a, b *Torrent) int {
	if a.NumComplete < b.NumComplete {
		return -1
	} else if a.NumComplete > b.NumComplete {
		return 1
	}
	return 0
}

func compareNumIncomplete(a, b *Torrent) int {
	if a.NumIncomplete < b.NumIncomplete {
		return -1
	} else if a.NumIncomplete > b.NumIncomplete {
		return 1
	}
	return 0
}

func compareNumLeechs(a, b *Torrent) int {
	if a.NumLeechs < b.NumLeechs {
		return -1
	} else if a.NumLeechs > b.NumLeechs {
		return 1
	}
	return 0
}

func compareNumSeeds(a, b *Torrent) int {
	if a.NumSeeds < b.NumSeeds {
		return -1
	} else if a.NumSeeds > b.NumSeeds {
		return 1
	}
	return 0
}

func comparePriority(a, b *Torrent) int {
	if a.Priority < b.Priority {
		return -1
	} else if a.Priority > b.Priority {
		return 1
	}
	return 0
}

func compareProgress(a, b *Torrent) int {
	if a.Progress < b.Progress {
		return -1
	} else if a.Progress > b.Progress {
		return 1
	}
	return 0
}

func compareRatio(a, b *Torrent) int {
	if a.Ratio < b.Ratio {
		return -1
	} else if a.Ratio > b.Ratio {
		return 1
	}
	return 0
}

func compareRatioLimit(a, b *Torrent) int {
	if a.RatioLimit < b.RatioLimit {
		return -1
	} else if a.RatioLimit > b.RatioLimit {
		return 1
	}
	return 0
}

func compareSavePath(a, b *Torrent) int {
	return strings.Compare(a.SavePath, b.SavePath)
}

func compareSeedingTime(a, b *Torrent) int {
	if a.SeedingTime < b.SeedingTime {
		return -1
	} else if a.SeedingTime > b.SeedingTime {
		return 1
	}
	return 0
}

func compareSeedingTimeLimit(a, b *Torrent) int {
	if a.SeedingTimeLimit < b.SeedingTimeLimit {
		return -1
	} else if a.SeedingTimeLimit > b.SeedingTimeLimit {
		return 1
	}
	return 0
}

func compareSeenComplete(a, b *Torrent) int {
	if a.SeenComplete < b.SeenComplete {
		return -1
	} else if a.SeenComplete > b.SeenComplete {
		return 1
	}
	return 0
}

func compareSequentialDownload(a, b *Torrent) int {
	if a.SequentialDownload != b.SequentialDownload {
		if a.SequentialDownload {
			return 1
		}
		return -1
	}
	return 0
}

func compareSize(a, b *Torrent) int {
	if a.Size < b.Size {
		return -1
	} else if a.Size > b.Size {
		return 1
	}
	return 0
}

func compareState(a, b *Torrent) int {
	return strings.Compare(string(a.State), string(b.State))
}

func compareSuperSeeding(a, b *Torrent) int {
	if a.SuperSeeding != b.SuperSeeding {
		if a.SuperSeeding {
			return 1
		}
		return -1
	}
	return 0
}

func compareTags(a, b *Torrent) int {
	return strings.Compare(a.Tags, b.Tags)
}

func compareTimeActive(a, b *Torrent) int {
	if a.TimeActive < b.TimeActive {
		return -1
	} else if a.TimeActive > b.TimeActive {
		return 1
	}
	return 0
}

func compareTotalSize(a, b *Torrent) int {
	if a.TotalSize < b.TotalSize {
		return -1
	} else if a.TotalSize > b.TotalSize {
		return 1
	}
	return 0
}

func compareTracker(a, b *Torrent) int {
	return strings.Compare(a.Tracker, b.Tracker)
}

func compareTrackersCount(a, b *Torrent) int {
	if a.TrackersCount < b.TrackersCount {
		return -1
	} else if a.TrackersCount > b.TrackersCount {
		return 1
	}
	return 0
}

func compareUpLimit(a, b *Torrent) int {
	if a.UpLimit < b.UpLimit {
		return -1
	} else if a.UpLimit > b.UpLimit {
		return 1
	}
	return 0
}

func compareUploaded(a, b *Torrent) int {
	if a.Uploaded < b.Uploaded {
		return -1
	} else if a.Uploaded > b.Uploaded {
		return 1
	}
	return 0
}

func compareUploadedSession(a, b *Torrent) int {
	if a.UploadedSession < b.UploadedSession {
		return -1
	} else if a.UploadedSession > b.UploadedSession {
		return 1
	}
	return 0
}

func compareUpSpeed(a, b *Torrent) int {
	if a.UpSpeed < b.UpSpeed {
		return -1
	} else if a.UpSpeed > b.UpSpeed {
		return 1
	}
	return 0
}

func compareDefault(a, b *Torrent) int {
	return strings.Compare(a.Name, b.Name)
}

// Precomputed comparators for sorting torrents
var torrentComparators = map[string]func(a, b *Torrent) int{
	"added_on": compareAddedOn,
	"amount_left": compareAmountLeft,
	"auto_tmm": compareAutoManaged,
	"availability": compareAvailability,
	"category": compareCategory,
	"completed": compareCompleted,
	"completion_on": compareCompletionOn,
	"content_path": compareContentPath,
	"dl_limit": compareDlLimit,
	"dlspeed": compareDlSpeed,
	"download_path": compareDownloadPath,
	"downloaded": compareDownloaded,
	"downloaded_session": compareDownloadedSession,
	"eta": compareETA,
	"f_l_piece_prio": compareFirstLastPiecePrio,
	"force_start": compareForceStart,
	"hash": compareHash,
	"infohash_v1": compareInfohashV1,
	"infohash_v2": compareInfohashV2,
	"last_activity": compareLastActivity,
	"magnet_uri": compareMagnetURI,
	"max_ratio": compareMaxRatio,
	"max_seeding_time": compareMaxSeedingTime,
	"name": compareName,
	"num_complete": compareNumComplete,
	"num_incomplete": compareNumIncomplete,
	"num_leechs": compareNumLeechs,
	"num_seeds": compareNumSeeds,
	"priority": comparePriority,
	"progress": compareProgress,
	"ratio": compareRatio,
	"ratio_limit": compareRatioLimit,
	"save_path": compareSavePath,
	"seeding_time": compareSeedingTime,
	"seeding_time_limit": compareSeedingTimeLimit,
	"seen_complete": compareSeenComplete,
	"seq_dl": compareSequentialDownload,
	"size": compareSize,
	"state": compareState,
	"super_seeding": compareSuperSeeding,
	"tags": compareTags,
	"time_active": compareTimeActive,
	"total_size": compareTotalSize,
	"tracker": compareTracker,
	"trackers_count": compareTrackersCount,
	"up_limit": compareUpLimit,
	"uploaded": compareUploaded,
	"uploaded_session": compareUploadedSession,
	"upspeed": compareUpSpeed,
	"default": compareDefault,
}

func applyTorrentSorting(torrents []Torrent, sortField string, reverse bool) {
	comparator, exists := torrentComparators[sortField]
	if !exists {
		comparator = torrentComparators["default"]
	}

	// Create indices to sort instead of large structs
	indices := make([]int, len(torrents))
	for i := range indices {
		indices[i] = i
	}

	// Sort indices using comparators on the original torrents
	slices.SortFunc(indices, func(i, j int) int {
		result := comparator(&torrents[i], &torrents[j])
		if result == 0 {
			result = strings.Compare(torrents[i].Hash, torrents[j].Hash) // secondary sort by hash for stability
		}
		if reverse {
			return -result
		}
		return result
	})

	// Apply permutation in place using selection sort approach
	for i := 0; i < len(torrents); i++ {
		// Find where element i should come from
		target := indices[i]
		for target < i {
			target = indices[target]
		}
		
		if target != i {
			torrents[i], torrents[target] = torrents[target], torrents[i]
			indices[target] = indices[i]
		}
	}
}

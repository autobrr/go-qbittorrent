// Code generated by go generate; DO NOT EDIT.
// This file was generated by internal/codegen/generate_torrent_filter.go

package qbittorrent

import (
	"cmp"
	"slices"
)
func compareAddedOn(a, b *Torrent) int {
	return cmp.Compare(a.AddedOn, b.AddedOn)
}

func compareAmountLeft(a, b *Torrent) int {
	return cmp.Compare(a.AmountLeft, b.AmountLeft)
}

func compareAutoManaged(a, b *Torrent) int {
	if a.AutoManaged != b.AutoManaged {
		if a.AutoManaged {
			return 1
		}
		return -1
	}
	return 0
}

func compareAvailability(a, b *Torrent) int {
	return cmp.Compare(a.Availability, b.Availability)
}

func compareCategory(a, b *Torrent) int {
	return cmp.Compare(a.Category, b.Category)
}

func compareCompleted(a, b *Torrent) int {
	return cmp.Compare(a.Completed, b.Completed)
}

func compareCompletionOn(a, b *Torrent) int {
	return cmp.Compare(a.CompletionOn, b.CompletionOn)
}

func compareContentPath(a, b *Torrent) int {
	return cmp.Compare(a.ContentPath, b.ContentPath)
}

func compareDlLimit(a, b *Torrent) int {
	return cmp.Compare(a.DlLimit, b.DlLimit)
}

func compareDlSpeed(a, b *Torrent) int {
	return cmp.Compare(a.DlSpeed, b.DlSpeed)
}

func compareDownloadPath(a, b *Torrent) int {
	return cmp.Compare(a.DownloadPath, b.DownloadPath)
}

func compareDownloaded(a, b *Torrent) int {
	return cmp.Compare(a.Downloaded, b.Downloaded)
}

func compareDownloadedSession(a, b *Torrent) int {
	return cmp.Compare(a.DownloadedSession, b.DownloadedSession)
}

func compareETA(a, b *Torrent) int {
	return cmp.Compare(a.ETA, b.ETA)
}

func compareFirstLastPiecePrio(a, b *Torrent) int {
	if a.FirstLastPiecePrio != b.FirstLastPiecePrio {
		if a.FirstLastPiecePrio {
			return 1
		}
		return -1
	}
	return 0
}

func compareForceStart(a, b *Torrent) int {
	if a.ForceStart != b.ForceStart {
		if a.ForceStart {
			return 1
		}
		return -1
	}
	return 0
}

func compareHash(a, b *Torrent) int {
	return cmp.Compare(a.Hash, b.Hash)
}

func compareInfohashV1(a, b *Torrent) int {
	return cmp.Compare(a.InfohashV1, b.InfohashV1)
}

func compareInfohashV2(a, b *Torrent) int {
	return cmp.Compare(a.InfohashV2, b.InfohashV2)
}

func compareLastActivity(a, b *Torrent) int {
	return cmp.Compare(a.LastActivity, b.LastActivity)
}

func compareMagnetURI(a, b *Torrent) int {
	return cmp.Compare(a.MagnetURI, b.MagnetURI)
}

func compareMaxRatio(a, b *Torrent) int {
	return cmp.Compare(a.MaxRatio, b.MaxRatio)
}

func compareMaxSeedingTime(a, b *Torrent) int {
	return cmp.Compare(a.MaxSeedingTime, b.MaxSeedingTime)
}

func compareName(a, b *Torrent) int {
	return cmp.Compare(a.Name, b.Name)
}

func compareNumComplete(a, b *Torrent) int {
	return cmp.Compare(a.NumComplete, b.NumComplete)
}

func compareNumIncomplete(a, b *Torrent) int {
	return cmp.Compare(a.NumIncomplete, b.NumIncomplete)
}

func compareNumLeechs(a, b *Torrent) int {
	return cmp.Compare(a.NumLeechs, b.NumLeechs)
}

func compareNumSeeds(a, b *Torrent) int {
	return cmp.Compare(a.NumSeeds, b.NumSeeds)
}

func comparePriority(a, b *Torrent) int {
	return cmp.Compare(a.Priority, b.Priority)
}

func compareProgress(a, b *Torrent) int {
	return cmp.Compare(a.Progress, b.Progress)
}

func compareRatio(a, b *Torrent) int {
	return cmp.Compare(a.Ratio, b.Ratio)
}

func compareRatioLimit(a, b *Torrent) int {
	return cmp.Compare(a.RatioLimit, b.RatioLimit)
}

func compareSavePath(a, b *Torrent) int {
	return cmp.Compare(a.SavePath, b.SavePath)
}

func compareSeedingTime(a, b *Torrent) int {
	return cmp.Compare(a.SeedingTime, b.SeedingTime)
}

func compareSeedingTimeLimit(a, b *Torrent) int {
	return cmp.Compare(a.SeedingTimeLimit, b.SeedingTimeLimit)
}

func compareSeenComplete(a, b *Torrent) int {
	return cmp.Compare(a.SeenComplete, b.SeenComplete)
}

func compareSequentialDownload(a, b *Torrent) int {
	if a.SequentialDownload != b.SequentialDownload {
		if a.SequentialDownload {
			return 1
		}
		return -1
	}
	return 0
}

func compareSize(a, b *Torrent) int {
	return cmp.Compare(a.Size, b.Size)
}

func compareState(a, b *Torrent) int {
	return cmp.Compare(string(a.State), string(b.State))
}

func compareSuperSeeding(a, b *Torrent) int {
	if a.SuperSeeding != b.SuperSeeding {
		if a.SuperSeeding {
			return 1
		}
		return -1
	}
	return 0
}

func compareTags(a, b *Torrent) int {
	return cmp.Compare(a.Tags, b.Tags)
}

func compareTimeActive(a, b *Torrent) int {
	return cmp.Compare(a.TimeActive, b.TimeActive)
}

func compareTotalSize(a, b *Torrent) int {
	return cmp.Compare(a.TotalSize, b.TotalSize)
}

func compareTracker(a, b *Torrent) int {
	return cmp.Compare(a.Tracker, b.Tracker)
}

func compareTrackersCount(a, b *Torrent) int {
	return cmp.Compare(a.TrackersCount, b.TrackersCount)
}

func compareUpLimit(a, b *Torrent) int {
	return cmp.Compare(a.UpLimit, b.UpLimit)
}

func compareUploaded(a, b *Torrent) int {
	return cmp.Compare(a.Uploaded, b.Uploaded)
}

func compareUploadedSession(a, b *Torrent) int {
	return cmp.Compare(a.UploadedSession, b.UploadedSession)
}

func compareUpSpeed(a, b *Torrent) int {
	return cmp.Compare(a.UpSpeed, b.UpSpeed)
}

func compareDefault(a, b *Torrent) int {
	return cmp.Compare(a.Name, b.Name)
}

// Precomputed comparators for sorting torrents
var torrentComparators = map[string]func(a, b *Torrent) int{
	"added_on": compareAddedOn,
	"amount_left": compareAmountLeft,
	"auto_tmm": compareAutoManaged,
	"availability": compareAvailability,
	"category": compareCategory,
	"completed": compareCompleted,
	"completion_on": compareCompletionOn,
	"content_path": compareContentPath,
	"dl_limit": compareDlLimit,
	"dlspeed": compareDlSpeed,
	"download_path": compareDownloadPath,
	"downloaded": compareDownloaded,
	"downloaded_session": compareDownloadedSession,
	"eta": compareETA,
	"f_l_piece_prio": compareFirstLastPiecePrio,
	"force_start": compareForceStart,
	"hash": compareHash,
	"infohash_v1": compareInfohashV1,
	"infohash_v2": compareInfohashV2,
	"last_activity": compareLastActivity,
	"magnet_uri": compareMagnetURI,
	"max_ratio": compareMaxRatio,
	"max_seeding_time": compareMaxSeedingTime,
	"name": compareName,
	"num_complete": compareNumComplete,
	"num_incomplete": compareNumIncomplete,
	"num_leechs": compareNumLeechs,
	"num_seeds": compareNumSeeds,
	"priority": comparePriority,
	"progress": compareProgress,
	"ratio": compareRatio,
	"ratio_limit": compareRatioLimit,
	"save_path": compareSavePath,
	"seeding_time": compareSeedingTime,
	"seeding_time_limit": compareSeedingTimeLimit,
	"seen_complete": compareSeenComplete,
	"seq_dl": compareSequentialDownload,
	"size": compareSize,
	"state": compareState,
	"super_seeding": compareSuperSeeding,
	"tags": compareTags,
	"time_active": compareTimeActive,
	"total_size": compareTotalSize,
	"tracker": compareTracker,
	"trackers_count": compareTrackersCount,
	"up_limit": compareUpLimit,
	"uploaded": compareUploaded,
	"uploaded_session": compareUploadedSession,
	"upspeed": compareUpSpeed,
	"default": compareDefault,
}

func applyTorrentSorting(torrents []Torrent, sortField string, reverse bool) {
	comparator, exists := torrentComparators[sortField]
	if !exists {
		comparator = torrentComparators["default"]
	}

	// Create indices to sort instead of large structs
	indices := make([]int, len(torrents))
	for i := range indices {
		indices[i] = i
	}

	// Sort indices using comparators on the original torrents
	slices.SortFunc(indices, func(i, j int) int {
		result := cmp.Or(
			comparator(&torrents[i], &torrents[j]),
			cmp.Compare(torrents[i].Hash, torrents[j].Hash), // secondary sort by hash for stability
		)
		if reverse {
			return -result
		}
		return result
	})

	// Rearrange torrents according to sorted indices
	sorted := make([]Torrent, len(torrents))
	for i, idx := range indices {
		sorted[i] = torrents[idx]
	}
	copy(torrents, sorted)
}

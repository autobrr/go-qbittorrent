// Code generated by go generate; DO NOT EDIT.
// This file was generated by internal/codegen/generate_torrent_filter.go

package qbittorrent

import (
	"slices"
)
func compareAddedOn(a, b *Torrent) int {
	if a.AddedOn < b.AddedOn {
		return -1
	} else if a.AddedOn > b.AddedOn {
		return 1
	}
	return 0
}

func compareAmountLeft(a, b *Torrent) int {
	if a.AmountLeft < b.AmountLeft {
		return -1
	} else if a.AmountLeft > b.AmountLeft {
		return 1
	}
	return 0
}

func compareAutoManaged(a, b *Torrent) int {
	if a.AutoManaged != b.AutoManaged {
		if a.AutoManaged {
			return 1
		}
		return -1
	}
	return 0
}

func compareAvailability(a, b *Torrent) int {
	if a.Availability < b.Availability {
		return -1
	} else if a.Availability > b.Availability {
		return 1
	}
	return 0
}

func compareCategory(a, b *Torrent) int {
	if a.Category == b.Category {
		return 0
	} else if a.Category < b.Category {
		return -1
	}
	return 1
}

func compareCompleted(a, b *Torrent) int {
	if a.Completed < b.Completed {
		return -1
	} else if a.Completed > b.Completed {
		return 1
	}
	return 0
}

func compareCompletionOn(a, b *Torrent) int {
	if a.CompletionOn < b.CompletionOn {
		return -1
	} else if a.CompletionOn > b.CompletionOn {
		return 1
	}
	return 0
}

func compareContentPath(a, b *Torrent) int {
	if a.ContentPath == b.ContentPath {
		return 0
	} else if a.ContentPath < b.ContentPath {
		return -1
	}
	return 1
}

func compareDlLimit(a, b *Torrent) int {
	if a.DlLimit < b.DlLimit {
		return -1
	} else if a.DlLimit > b.DlLimit {
		return 1
	}
	return 0
}

func compareDlSpeed(a, b *Torrent) int {
	if a.DlSpeed < b.DlSpeed {
		return -1
	} else if a.DlSpeed > b.DlSpeed {
		return 1
	}
	return 0
}

func compareDownloadPath(a, b *Torrent) int {
	if a.DownloadPath == b.DownloadPath {
		return 0
	} else if a.DownloadPath < b.DownloadPath {
		return -1
	}
	return 1
}

func compareDownloaded(a, b *Torrent) int {
	if a.Downloaded < b.Downloaded {
		return -1
	} else if a.Downloaded > b.Downloaded {
		return 1
	}
	return 0
}

func compareDownloadedSession(a, b *Torrent) int {
	if a.DownloadedSession < b.DownloadedSession {
		return -1
	} else if a.DownloadedSession > b.DownloadedSession {
		return 1
	}
	return 0
}

func compareETA(a, b *Torrent) int {
	if a.ETA < b.ETA {
		return -1
	} else if a.ETA > b.ETA {
		return 1
	}
	return 0
}

func compareFirstLastPiecePrio(a, b *Torrent) int {
	if a.FirstLastPiecePrio != b.FirstLastPiecePrio {
		if a.FirstLastPiecePrio {
			return 1
		}
		return -1
	}
	return 0
}

func compareForceStart(a, b *Torrent) int {
	if a.ForceStart != b.ForceStart {
		if a.ForceStart {
			return 1
		}
		return -1
	}
	return 0
}

func compareHash(a, b *Torrent) int {
	if a.Hash == b.Hash {
		return 0
	} else if a.Hash < b.Hash {
		return -1
	}
	return 1
}

func compareInfohashV1(a, b *Torrent) int {
	if a.InfohashV1 == b.InfohashV1 {
		return 0
	} else if a.InfohashV1 < b.InfohashV1 {
		return -1
	}
	return 1
}

func compareInfohashV2(a, b *Torrent) int {
	if a.InfohashV2 == b.InfohashV2 {
		return 0
	} else if a.InfohashV2 < b.InfohashV2 {
		return -1
	}
	return 1
}

func compareLastActivity(a, b *Torrent) int {
	if a.LastActivity < b.LastActivity {
		return -1
	} else if a.LastActivity > b.LastActivity {
		return 1
	}
	return 0
}

func compareMagnetURI(a, b *Torrent) int {
	if a.MagnetURI == b.MagnetURI {
		return 0
	} else if a.MagnetURI < b.MagnetURI {
		return -1
	}
	return 1
}

func compareMaxRatio(a, b *Torrent) int {
	if a.MaxRatio < b.MaxRatio {
		return -1
	} else if a.MaxRatio > b.MaxRatio {
		return 1
	}
	return 0
}

func compareMaxSeedingTime(a, b *Torrent) int {
	if a.MaxSeedingTime < b.MaxSeedingTime {
		return -1
	} else if a.MaxSeedingTime > b.MaxSeedingTime {
		return 1
	}
	return 0
}

func compareName(a, b *Torrent) int {
	if a.Name == b.Name {
		return 0
	} else if a.Name < b.Name {
		return -1
	}
	return 1
}

func compareNumComplete(a, b *Torrent) int {
	if a.NumComplete < b.NumComplete {
		return -1
	} else if a.NumComplete > b.NumComplete {
		return 1
	}
	return 0
}

func compareNumIncomplete(a, b *Torrent) int {
	if a.NumIncomplete < b.NumIncomplete {
		return -1
	} else if a.NumIncomplete > b.NumIncomplete {
		return 1
	}
	return 0
}

func compareNumLeechs(a, b *Torrent) int {
	if a.NumLeechs < b.NumLeechs {
		return -1
	} else if a.NumLeechs > b.NumLeechs {
		return 1
	}
	return 0
}

func compareNumSeeds(a, b *Torrent) int {
	if a.NumSeeds < b.NumSeeds {
		return -1
	} else if a.NumSeeds > b.NumSeeds {
		return 1
	}
	return 0
}

func comparePriority(a, b *Torrent) int {
	if a.Priority < b.Priority {
		return -1
	} else if a.Priority > b.Priority {
		return 1
	}
	return 0
}

func compareProgress(a, b *Torrent) int {
	if a.Progress < b.Progress {
		return -1
	} else if a.Progress > b.Progress {
		return 1
	}
	return 0
}

func compareRatio(a, b *Torrent) int {
	if a.Ratio < b.Ratio {
		return -1
	} else if a.Ratio > b.Ratio {
		return 1
	}
	return 0
}

func compareRatioLimit(a, b *Torrent) int {
	if a.RatioLimit < b.RatioLimit {
		return -1
	} else if a.RatioLimit > b.RatioLimit {
		return 1
	}
	return 0
}

func compareSavePath(a, b *Torrent) int {
	if a.SavePath == b.SavePath {
		return 0
	} else if a.SavePath < b.SavePath {
		return -1
	}
	return 1
}

func compareSeedingTime(a, b *Torrent) int {
	if a.SeedingTime < b.SeedingTime {
		return -1
	} else if a.SeedingTime > b.SeedingTime {
		return 1
	}
	return 0
}

func compareSeedingTimeLimit(a, b *Torrent) int {
	if a.SeedingTimeLimit < b.SeedingTimeLimit {
		return -1
	} else if a.SeedingTimeLimit > b.SeedingTimeLimit {
		return 1
	}
	return 0
}

func compareSeenComplete(a, b *Torrent) int {
	if a.SeenComplete < b.SeenComplete {
		return -1
	} else if a.SeenComplete > b.SeenComplete {
		return 1
	}
	return 0
}

func compareSequentialDownload(a, b *Torrent) int {
	if a.SequentialDownload != b.SequentialDownload {
		if a.SequentialDownload {
			return 1
		}
		return -1
	}
	return 0
}

func compareSize(a, b *Torrent) int {
	if a.Size < b.Size {
		return -1
	} else if a.Size > b.Size {
		return 1
	}
	return 0
}

func compareState(a, b *Torrent) int {
	if a.State == b.State {
		return 0
	} else if string(a.State) < string(b.State) {
		return -1
	}
	return 1
}

func compareSuperSeeding(a, b *Torrent) int {
	if a.SuperSeeding != b.SuperSeeding {
		if a.SuperSeeding {
			return 1
		}
		return -1
	}
	return 0
}

func compareTags(a, b *Torrent) int {
	if a.Tags == b.Tags {
		return 0
	} else if a.Tags < b.Tags {
		return -1
	}
	return 1
}

func compareTimeActive(a, b *Torrent) int {
	if a.TimeActive < b.TimeActive {
		return -1
	} else if a.TimeActive > b.TimeActive {
		return 1
	}
	return 0
}

func compareTotalSize(a, b *Torrent) int {
	if a.TotalSize < b.TotalSize {
		return -1
	} else if a.TotalSize > b.TotalSize {
		return 1
	}
	return 0
}

func compareTracker(a, b *Torrent) int {
	if a.Tracker == b.Tracker {
		return 0
	} else if a.Tracker < b.Tracker {
		return -1
	}
	return 1
}

func compareTrackersCount(a, b *Torrent) int {
	if a.TrackersCount < b.TrackersCount {
		return -1
	} else if a.TrackersCount > b.TrackersCount {
		return 1
	}
	return 0
}

func compareUpLimit(a, b *Torrent) int {
	if a.UpLimit < b.UpLimit {
		return -1
	} else if a.UpLimit > b.UpLimit {
		return 1
	}
	return 0
}

func compareUploaded(a, b *Torrent) int {
	if a.Uploaded < b.Uploaded {
		return -1
	} else if a.Uploaded > b.Uploaded {
		return 1
	}
	return 0
}

func compareUploadedSession(a, b *Torrent) int {
	if a.UploadedSession < b.UploadedSession {
		return -1
	} else if a.UploadedSession > b.UploadedSession {
		return 1
	}
	return 0
}

func compareUpSpeed(a, b *Torrent) int {
	if a.UpSpeed < b.UpSpeed {
		return -1
	} else if a.UpSpeed > b.UpSpeed {
		return 1
	}
	return 0
}

func compareDefault(a, b *Torrent) int {
	if a.Name == b.Name {
		return 0
	} else if a.Name < b.Name {
		return -1
	}
	return 1
}

// Precomputed comparators for sorting torrents
var torrentComparators = map[string]func(a, b *Torrent) int{
	"added_on": compareAddedOn,
	"amount_left": compareAmountLeft,
	"auto_tmm": compareAutoManaged,
	"availability": compareAvailability,
	"category": compareCategory,
	"completed": compareCompleted,
	"completion_on": compareCompletionOn,
	"content_path": compareContentPath,
	"dl_limit": compareDlLimit,
	"dlspeed": compareDlSpeed,
	"download_path": compareDownloadPath,
	"downloaded": compareDownloaded,
	"downloaded_session": compareDownloadedSession,
	"eta": compareETA,
	"f_l_piece_prio": compareFirstLastPiecePrio,
	"force_start": compareForceStart,
	"hash": compareHash,
	"infohash_v1": compareInfohashV1,
	"infohash_v2": compareInfohashV2,
	"last_activity": compareLastActivity,
	"magnet_uri": compareMagnetURI,
	"max_ratio": compareMaxRatio,
	"max_seeding_time": compareMaxSeedingTime,
	"name": compareName,
	"num_complete": compareNumComplete,
	"num_incomplete": compareNumIncomplete,
	"num_leechs": compareNumLeechs,
	"num_seeds": compareNumSeeds,
	"priority": comparePriority,
	"progress": compareProgress,
	"ratio": compareRatio,
	"ratio_limit": compareRatioLimit,
	"save_path": compareSavePath,
	"seeding_time": compareSeedingTime,
	"seeding_time_limit": compareSeedingTimeLimit,
	"seen_complete": compareSeenComplete,
	"seq_dl": compareSequentialDownload,
	"size": compareSize,
	"state": compareState,
	"super_seeding": compareSuperSeeding,
	"tags": compareTags,
	"time_active": compareTimeActive,
	"total_size": compareTotalSize,
	"tracker": compareTracker,
	"trackers_count": compareTrackersCount,
	"up_limit": compareUpLimit,
	"uploaded": compareUploaded,
	"uploaded_session": compareUploadedSession,
	"upspeed": compareUpSpeed,
	"default": compareDefault,
}

// torrentSorter is a reusable struct for sorting torrents without allocations
type torrentSorter struct {
	torrents   []Torrent
	comparator func(a, b *Torrent) int
	reverse    bool
}

// compare is a static method that doesn't allocate
func (s *torrentSorter) compare(i, j int) int {
	result := s.comparator(&s.torrents[i], &s.torrents[j])
	if result == 0 {
		if s.torrents[i].Hash == s.torrents[j].Hash {
			result = 0
		} else if s.torrents[i].Hash < s.torrents[j].Hash {
			result = -1
		} else {
			result = 1
		} // secondary sort by hash for stability
	}
	if s.reverse {
		return -result
	}
	return result
}

func applyTorrentSorting(torrents []Torrent, sortField string, reverse bool) {
	comparator, exists := torrentComparators[sortField]
	if !exists {
		comparator = torrentComparators["default"]
	}

	// Create indices to sort instead of large structs
	indices := make([]int, len(torrents))
	for i := range indices {
		indices[i] = i
	}

	sorter := &torrentSorter{
		torrents:  torrents,
		comparator: comparator,
		reverse:   reverse,
	}

	// Sort indices using the static method - no allocation!
	slices.SortFunc(indices, sorter.compare)

	// Apply permutation in place using cycle decomposition
	for i := 0; i < len(torrents); i++ {
		if indices[i] != i {
			// Start of a cycle
			temp := torrents[i]
			j := i
			for {
				k := indices[j]
				indices[j] = j // Mark as processed
				if k == i {
					torrents[j] = temp
					break
				}
				torrents[j] = torrents[k]
				j = k
			}
		}
	}
}

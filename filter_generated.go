// Code generated by go generate; DO NOT EDIT.
// This file was generated by internal/codegen/generate_torrent_filter.go

package qbittorrent

import (
	"cmp"
	"slices"
)

// Precomputed comparators for sorting torrents
var torrentComparators = map[string]func(a, b Torrent) int{
	"added_on": func(a, b Torrent) int {
		return cmp.Compare(a.AddedOn, b.AddedOn)
	},
	"amount_left": func(a, b Torrent) int {
		return cmp.Compare(a.AmountLeft, b.AmountLeft)
	},
	"auto_tmm": func(a, b Torrent) int {
		if a.AutoManaged != b.AutoManaged {
			if a.AutoManaged {
				return 1
			}
			return -1
		}
		return 0
	},
	"availability": func(a, b Torrent) int {
		return cmp.Compare(a.Availability, b.Availability)
	},
	"category": func(a, b Torrent) int {
		return cmp.Compare(a.Category, b.Category)
	},
	"completed": func(a, b Torrent) int {
		return cmp.Compare(a.Completed, b.Completed)
	},
	"completion_on": func(a, b Torrent) int {
		return cmp.Compare(a.CompletionOn, b.CompletionOn)
	},
	"content_path": func(a, b Torrent) int {
		return cmp.Compare(a.ContentPath, b.ContentPath)
	},
	"dl_limit": func(a, b Torrent) int {
		return cmp.Compare(a.DlLimit, b.DlLimit)
	},
	"dlspeed": func(a, b Torrent) int {
		return cmp.Compare(a.DlSpeed, b.DlSpeed)
	},
	"download_path": func(a, b Torrent) int {
		return cmp.Compare(a.DownloadPath, b.DownloadPath)
	},
	"downloaded": func(a, b Torrent) int {
		return cmp.Compare(a.Downloaded, b.Downloaded)
	},
	"downloaded_session": func(a, b Torrent) int {
		return cmp.Compare(a.DownloadedSession, b.DownloadedSession)
	},
	"eta": func(a, b Torrent) int {
		return cmp.Compare(a.ETA, b.ETA)
	},
	"f_l_piece_prio": func(a, b Torrent) int {
		if a.FirstLastPiecePrio != b.FirstLastPiecePrio {
			if a.FirstLastPiecePrio {
				return 1
			}
			return -1
		}
		return 0
	},
	"force_start": func(a, b Torrent) int {
		if a.ForceStart != b.ForceStart {
			if a.ForceStart {
				return 1
			}
			return -1
		}
		return 0
	},
	"hash": func(a, b Torrent) int {
		return cmp.Compare(a.Hash, b.Hash)
	},
	"infohash_v1": func(a, b Torrent) int {
		return cmp.Compare(a.InfohashV1, b.InfohashV1)
	},
	"infohash_v2": func(a, b Torrent) int {
		return cmp.Compare(a.InfohashV2, b.InfohashV2)
	},
	"last_activity": func(a, b Torrent) int {
		return cmp.Compare(a.LastActivity, b.LastActivity)
	},
	"magnet_uri": func(a, b Torrent) int {
		return cmp.Compare(a.MagnetURI, b.MagnetURI)
	},
	"max_ratio": func(a, b Torrent) int {
		return cmp.Compare(a.MaxRatio, b.MaxRatio)
	},
	"max_seeding_time": func(a, b Torrent) int {
		return cmp.Compare(a.MaxSeedingTime, b.MaxSeedingTime)
	},
	"name": func(a, b Torrent) int {
		return cmp.Compare(a.Name, b.Name)
	},
	"num_complete": func(a, b Torrent) int {
		return cmp.Compare(a.NumComplete, b.NumComplete)
	},
	"num_incomplete": func(a, b Torrent) int {
		return cmp.Compare(a.NumIncomplete, b.NumIncomplete)
	},
	"num_leechs": func(a, b Torrent) int {
		return cmp.Compare(a.NumLeechs, b.NumLeechs)
	},
	"num_seeds": func(a, b Torrent) int {
		return cmp.Compare(a.NumSeeds, b.NumSeeds)
	},
	"priority": func(a, b Torrent) int {
		return cmp.Compare(a.Priority, b.Priority)
	},
	"progress": func(a, b Torrent) int {
		return cmp.Compare(a.Progress, b.Progress)
	},
	"ratio": func(a, b Torrent) int {
		return cmp.Compare(a.Ratio, b.Ratio)
	},
	"ratio_limit": func(a, b Torrent) int {
		return cmp.Compare(a.RatioLimit, b.RatioLimit)
	},
	"save_path": func(a, b Torrent) int {
		return cmp.Compare(a.SavePath, b.SavePath)
	},
	"seeding_time": func(a, b Torrent) int {
		return cmp.Compare(a.SeedingTime, b.SeedingTime)
	},
	"seeding_time_limit": func(a, b Torrent) int {
		return cmp.Compare(a.SeedingTimeLimit, b.SeedingTimeLimit)
	},
	"seen_complete": func(a, b Torrent) int {
		return cmp.Compare(a.SeenComplete, b.SeenComplete)
	},
	"seq_dl": func(a, b Torrent) int {
		if a.SequentialDownload != b.SequentialDownload {
			if a.SequentialDownload {
				return 1
			}
			return -1
		}
		return 0
	},
	"size": func(a, b Torrent) int {
		return cmp.Compare(a.Size, b.Size)
	},
	"state": func(a, b Torrent) int {
		return cmp.Compare(string(a.State), string(b.State))
	},
	"super_seeding": func(a, b Torrent) int {
		if a.SuperSeeding != b.SuperSeeding {
			if a.SuperSeeding {
				return 1
			}
			return -1
		}
		return 0
	},
	"tags": func(a, b Torrent) int {
		return cmp.Compare(a.Tags, b.Tags)
	},
	"time_active": func(a, b Torrent) int {
		return cmp.Compare(a.TimeActive, b.TimeActive)
	},
	"total_size": func(a, b Torrent) int {
		return cmp.Compare(a.TotalSize, b.TotalSize)
	},
	"tracker": func(a, b Torrent) int {
		return cmp.Compare(a.Tracker, b.Tracker)
	},
	"trackers_count": func(a, b Torrent) int {
		return cmp.Compare(a.TrackersCount, b.TrackersCount)
	},
	"up_limit": func(a, b Torrent) int {
		return cmp.Compare(a.UpLimit, b.UpLimit)
	},
	"uploaded": func(a, b Torrent) int {
		return cmp.Compare(a.Uploaded, b.Uploaded)
	},
	"uploaded_session": func(a, b Torrent) int {
		return cmp.Compare(a.UploadedSession, b.UploadedSession)
	},
	"upspeed": func(a, b Torrent) int {
		return cmp.Compare(a.UpSpeed, b.UpSpeed)
	},
	"default": func(a, b Torrent) int {
		return cmp.Compare(a.Name, b.Name)
	},
}

func applyTorrentSorting(torrents []Torrent, sortField string, reverse bool) {
	if sortField == "" {
		return
	}

	comparator, exists := torrentComparators[sortField]
	if !exists {
		comparator = torrentComparators["default"]
	}

	slices.SortFunc(torrents, func(a, b Torrent) int {
		result := cmp.Or(
			comparator(a, b),
			cmp.Compare(a.Hash, b.Hash), // secondary sort by hash for stability
		)
		if reverse {
			return -result
		}
		return result
	})
}
